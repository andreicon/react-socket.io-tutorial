# react-socket.io-tutorial
## A tutorial on how to use react with socket.io

### Server setup

First let's create a node server to handle our requests and socket connections.

##### In a terminal console type:

    mkdir react-tutorial && cd $_
    npm init
    
Give your new app a name and type a filename for the entry script (server.js in this tutorial).

##### Install dependencies:

```bash
npm install --save express
npm install --save socket.io
```
    
##### Create the server script:

```js
var express = require('express'),
app = express(),
path = require('path'),
fs = require('fs'),
http = require('http').Server(app),
io = require('socket.io')(http);

app.use(express.static(path.join(__dirname, './public')));

var COMMENTS_FILE = path.join(__dirname, 'comments.json');

io.on('connection', function (socket) {
    console.log('User connected. Socket id %s', socket.id);

    socket.on('getComments', function (data) {
        fs.readFile(COMMENTS_FILE, function(err, data) {
            if (err) {
                console.error(err);
                socket.emit('comments',{});
            } else {
                var payload = JSON.parse(data);
                socket.emit('comments',payload);
            }
        });
    });

    socket.on('sendComments', function (comment) {
        fs.readFile(COMMENTS_FILE, function(err, data) {
            if (err) {
              console.error(err);
              process.exit(1);
            }
            var comments = JSON.parse(data);
            // NOTE: In a real implementation, we would likely rely on a database or
            // some other approach (e.g. UUIDs) to ensure a globally unique id. We'll
            // treat Date.now() as unique-enough for our purposes.
            var newComment = {
              id: Date.now(),
              author: comment.author,
              text: comment.text,
            };
            comments.push(newComment);
            fs.writeFile(COMMENTS_FILE, JSON.stringify(comments, null, 4), function(err) {
                socket.emit('comments', comments);
            });
        });
    });

    socket.on('disconnect', function () {
        console.log('User disconnected. %s. Socket id %s', socket.id);
    });
});

http.listen(process.env.PORT || 3000);
```

##### Client-side markup
    
We'll have to create a `public` folder and subfolders for `css` and `js` files.

Create a `index.html` file in the root of the `public` folder:

```html
<!DOCTYPE html>
<html>
    <head>
        <title>A tutorial on how to use react with socket.io</title>
        <link rel="stylesheet" href="/css/style.css" type="text/css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script>
        <script src="/socket.io/socket.io.js"></script>
    </head>
    <body>
        <div id="content"></div>
        <script type="text/babel" src="/js/app.jsx"></script>
    </body>
</html>
```

##### Client-side script
    
We will need to add a javascript file to handle getting and inserting the comments

```jsx
var socket = io();

var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        <span dangerouslySetInnerHTML={this.rawMarkup()} />
      </div>
    );
  }
});

var CommentBox = React.createClass({
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    socket.emit('sendComments', comment);
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    socket.emit('getComments', {date: new Date});
    var box = this;
    socket.on('comments', function(comments){
        box.setState({data: comments});
    });
    setInterval(function(){
        socket.emit('getComments', {date: new Date});
    }, this.props.pollInterval);
  },
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.state.data} />
        <CommentForm onCommentSubmit={this.handleCommentSubmit} />
      </div>
    );
  }
});

var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        <Comment author={comment.author} key={comment.id}>
          {comment.text}
        </Comment>
      );
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: '', text: ''};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    this.props.onCommentSubmit({author: author, text: text});
    this.setState({author: '', text: ''});
  },
  render: function() {
    return (
      <form className="commentForm" onSubmit={this.handleSubmit}>
        <input
          type="text"
          placeholder="Your name"
          value={this.state.author}
          onChange={this.handleAuthorChange}
        />
        <input
          type="text"
          placeholder="Say something..."
          value={this.state.text}
          onChange={this.handleTextChange}
        />
        <input type="submit" value="Post" />
      </form>
    );
  }
});

ReactDOM.render(
  <CommentBox pollInterval={2000} />,
  document.getElementById('content')
);
```
    
Save this file as `public/js/app.jsx`. Next up a little bit of styling for our form. Save in `public/css/style.css`:

```css
body {
    background: #fff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 15px;
    line-height: 1.7;
    margin: 0;
    padding: 30px;
}

a {
    color: #4183c4;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

code {
    background-color: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-family: "Bitstream Vera Sans Mono", Consolas, Courier, monospace;
    font-size: 12px;
    margin: 0 2px;
    padding: 0px 5px;
}

h1, h2, h3, h4 {
    font-weight: bold;
    margin: 0 0 15px;
    padding: 0;
}

h1 {
    border-bottom: 1px solid #ddd;
    font-size: 2.5em;
    font-weight: bold;
    margin: 0 0 15px;
    padding: 0;
}

h2 {
    border-bottom: 1px solid #eee;
    font-size: 2em;
}

h3 {
    font-size: 1.5em;
}

h4 {
    font-size: 1.2em;
}

p, ul {
    margin: 15px 0;
}

ul {
    padding-left: 30px;
}
```

All done. All we need now is a `comments.json` file that will be keeping your data instead of using a real database (it should be enough for the purpose of this tutorial).